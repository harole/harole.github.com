<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Harole's blog]]></title>
  <link href="http://harole.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://harole.github.com/"/>
  <updated>2013-10-05T20:47:34+08:00</updated>
  <id>http://harole.github.com/</id>
  <author>
    <name><![CDATA[harole]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[javascript 异步初始化大数组]]></title>
    <link href="http://harole.github.com/blog/2013/10/05/initbigarrayasync/"/>
    <updated>2013-10-05T17:26:00+08:00</updated>
    <id>http://harole.github.com/blog/2013/10/05/initbigarrayasync</id>
    <content type="html"><![CDATA[<pre><code>    var THRESHOLD = 150, DELAY = 15;

    function initBigArrayAsync(max, cb) {
        var r = [], i = 0;

        function init(startTime) {
            while (i &lt; max) {
                if (new Date - startTime &lt; THRESHOLD) {
                    r[i++] = i;
                } else {
                    setTimeout(function() {
                        init(new Date);
                    }, DELAY);
                    return;
                }
            }

            cb(r);
        }

        init(new Date);
    }

    initBigArrayAsync(1000000, function(arr) {
        console.log(arr.length);
        console.log(arr[1000000 - 1]);
    });
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript 循环（for，while）那些事儿！]]></title>
    <link href="http://harole.github.com/blog/2013/10/05/looping-techniques-javascript/"/>
    <updated>2013-10-05T00:16:00+08:00</updated>
    <id>http://harole.github.com/blog/2013/10/05/looping-techniques-javascript</id>
    <content type="html"><![CDATA[<ol>
<li><p>for 类循环</p>

<ol>
<li><p>for-in 循环的一般形式</p>

<pre><code> // i 可以是数组的下标，也可以是对象的属性
 // arr 可以是数组，也可以是对象
 for ( i in arr ) {

     // 如需匹配特定的值
     // 可以使用一个判断语句
     // definited 为匹配值的变量
     if ( arr[i] === definited ) {

     }
 }
</code></pre>

<p>总结：for-in 语句不仅可以对数组循环遍历，还可以对对象的属性循环遍历
<!-- more --></p></li>
<li><p>for 循环一般形式</p>

<pre><code> for ( var i = 0; i &lt; arr.length; i++ ) {

 }
</code></pre>

<p>总结：每次都需要去查找数组的 length 属性，可以通过缓存 length 来稍微提升遍历的速度</p></li>
<li><p>for 缓存数组的 length 属性</p>

<pre><code> for ( var i = 0, l = arr.length; i &lt; l; i++ ) {

 }
</code></pre>

<p>总结：如果遍历的是HTMLCollection，性能提升比较明显。因为每次访问HTMLCollection的属性，HTMLCollection都会内部匹配一次所有的节点。</p></li>
<li><p>遍历数组操作中，不判断下标，直接判断数组元素是否存在，再对元素进行操作。</p>

<pre><code> var currentItem;
 for ( var i = 0; items[i]; i++ ) {
     currentItem = items[i];
 }

 // 例如：遍历 DOM 子元素
 for ( node = parent.firstChild; node; node = node.nextSibling ) {  
     if ( node.nodeType === 1 ) {  
         node.nodeIndex = ++count;  
     }  
 }
</code></pre></li>
<li><p>在迭代中，要尽可能少遍历，如果知道从 position 开始。</p>

<pre><code> var currentItem;
 for ( var i = position || 0, l = items.length; i &lt; l; i++ ) {
     currentItem = items[i];
 }
</code></pre></li>
<li><p>倒序遍历可以减少几个字符。</p>

<pre><code> for ( var i = items.length, currentItem; i; ) {
     currentItem = items[--i];  // 合并了 i 自减和 i 取值的操作
 }    
</code></pre></li>
</ol>
</li>
<li><p>while 循环</p>

<ol>
<li><p>通过 while 检测下标遍历。</p>

<pre><code> var l = arr.length, currentItem;
 while ( --l ) {
     currentItem = arr[l];
 }
</code></pre></li>
<li><p>while 检测元素</p>

<pre><code> var findType, i = 0;
 while ( findType == arr[i++] ) {
     // 一些操作 
 }
</code></pre></li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Function()构造函数，即用 new Function() 方式构造函数]]></title>
    <link href="http://harole.github.com/blog/2013/10/01/new-function/"/>
    <updated>2013-10-01T14:38:00+08:00</updated>
    <id>http://harole.github.com/blog/2013/10/01/new-function</id>
    <content type="html"><![CDATA[<p>一. 下面是使用Functin()构造函数来创建一个函数的例子：</p>

<pre><code>var f = new Function( "x", "y", "return x + y;" );
</code></pre>

<p>这行代码创建了一个新函数，这个函数和下面的定义基本相等</p>

<pre><code>function f( x, y ){
    return x + y;
}
</code></pre>

<p>Function构造函数期待任意数目的 <strong>字符串</strong> 参数，其中最后一个参数（它可以包含任意多条 javascript 语句）是函数的函数体，其他均是函数的参数。如果需要定义一个没有参数的函数体，只需向构造函数传入一个字符串参数，也就是函数体。</p>

<!-- more -->


<p>二. 关于Function()构造函数需要理解以下几点：</p>

<pre><code>* Function()构造函数润允许javascript代码被动态地创建而且在运行时编译。
  全局的eval()函数也是这种方式。

* Function()构造函数解析函数体，并且每次被调用时都创建一个新的函数对象。

    缺点：如果构造函数的调用出现在一个循环中，或者出现在一个经常被调用的函数中，
          那么过程的效率将会很低。

    优点：如果构造函数的调用出现在一个循环或是函数中的直接量中的函数直接量或者
          嵌套的函数，并不会每次遇到的时候都编译。

* Function()构造函数，他所创建的函数并不适用词法作用域，而是当作顶层的函数一样编译。
  如下面代码所示:
  var y = "global";
function a(){

    var y = "local1";
    function constructFunction() {
        var y = "local";
        return new Function("return y;");
    }

    // 这里 constructFunction()()
    // 第一个 '()' 是执行 constructFunction 函数
    // 第二个 '()' 是执行constructFunction 函数返回的 'new Function()' 函数。
    alert(constructFunction()()); // 显示global
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数方法call()和apply()的使用和区别]]></title>
    <link href="http://harole.github.com/blog/2013/09/29/func-method-call-and-apply/"/>
    <updated>2013-09-29T22:40:00+08:00</updated>
    <id>http://harole.github.com/blog/2013/09/29/func-method-call-and-apply</id>
    <content type="html"><![CDATA[<p><strong>call()</strong> 方法和 <strong>apply()</strong> 方法的第一个参数都是要调用的函数对象，在函数体内这一参数是关键字 <strong>this</strong> 的值。call()剩余的参数是传递给要调用的函数的值。</p>

<pre><code>var O = {};

function f( a, b ) {
    console.log(a);
    console.log(b);
}   

// call()方法的使用，当前 **this** 指向的是对象O
f.call( O, 1, 2 );

// call()方法的实现与下面代码实现相似，可以通过下面的代码来理解call()的使用。    
O.m = f;
O.m();
delete O.m;

// apply()方法和call()方法相似，区别在于apply传递给函数的参数是由数组指定的：
f.apply( O, [1,2] );
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[像 html 模块化一样，模块化 javascript 事件处理程序，使之可维护！]]></title>
    <link href="http://harole.github.com/blog/2013/04/10/javascript-event-handle/"/>
    <updated>2013-04-10T12:49:00+08:00</updated>
    <id>http://harole.github.com/blog/2013/04/10/javascript-event-handle</id>
    <content type="html"><![CDATA[<p>一. 常用的事件处理程序</p>

<pre><code>funciton handleClick( event ) {

    var popWindow = document.getElementById("popWindow");

    popWindow.style.left = event.clientX + "px";
    popWindow.style.top = event.clientY + "px"; 

    popWindow.className = "visible";

}
addListener(element, "click", handleClcik); 
</code></pre>

<p>上述程序功能：监听 "element" 元素的 click 事件，当触发 click 事件时，显示一个窗口到当前鼠标位置。</p>

<p>缺点：事件处理程序包含了应用逻辑，即应用逻辑只和 click 事件相关。但是 mousehover，mouseup 等其他事件也要实现同样的功能。会有如下实现：</p>

<!-- more -->


<pre><code>// mousehover
funciton handleMouseHover( event ) {

    var popWindow = document.getElementById("popWindow");

    popWindow.style.left = event.clientX + "px";
    popWindow.style.top = event.clientY + "px"; 

    popWindow.className = "visible";

}
addListener(element, "mousehover", handleMouseHover);       

// mouseup
funciton handleMouseUp( event ) {

    var popWindow = document.getElementById("popWindow");

    popWindow.style.left = event.clientX + "px";
    popWindow.style.top = event.clientY + "px"; 

    popWindow.className = "visible";

}
addListener(element, "mousehover", handleMouseUp);      

// 其他事件
......
</code></pre>

<p>很明显上面的代码被复制了多，于是我们又有了如下代码：</p>

<pre><code>// eventHandle
funciton eventHandle( event ) {

    var popWindow = document.getElementById("popWindow");

    popWindow.style.left = event.clientX + "px";
    popWindow.style.top = event.clientY + "px"; 

    popWindow.className = "visible";

}
addListener(element, "click", eventHandle); 
addListener(element, "mousehover", eventHandle);        
addListener(element, "mousehover", eventHandle);    

// 其他监听事件
......
</code></pre>

<p>恩恩，经过两次改进，我们将应用逻辑从事件处理程序中隔离了。但是，问题并没有解决，因为你监听的事件
"click", "mousehover", "mouseup"等的处理程序大部分情况下是不一样的。于是有了如下方案：</p>

<p>二. 隔离应用逻辑</p>

<pre><code>var app =  {

    showPopWindow: function (event) {

        var popWindow = document.getElementById("popWindow");

        popWindow.style.left = event.clientX + "px";
        popWindow.style.top = event.clientY + "px";         

    },

    handleClick: function (event) {

        this.showPopWindow( event );

        // click 的其他代码
        ......
    },

    handleMouseHover: function (event) {

        this.showPopWindow( event );

        // mousehover 的其他代码
        ......

    }

    // 其他事件处理函数
    ......      
};

addListener(element, "click", function (event) {
    app.handleClick(event);
});

addListener(element, "mousehover", function (event) {
    app.handleMouseHover(event);
});

// 其他事件的监听
......
</code></pre>

<p>隔离应用逻辑后，代码还存在一个问题，即 event 对象被无节制的分发（event 由 addListener 传入了 app.handleClick 或 app.handleMouseHover，再传入app.showPopWindow）。</p>

<p>三. 不要分发事件对象</p>

<p>应用逻辑 showPopWindow 不应该依赖于 event 对象来完成功能。如果想要测试这个方法，必须重新创建一个 event 对象，否则在函数内无法找到 event.clientX 和 event.clientY，就无法测试。所以做了如下改进：</p>

<pre><code>var app =  {

    showPopWindow: function ( x, y ) {

        var popWindow = document.getElementById("popWindow");

        popWindow.style.left = x + "px";
        popWindow.style.top = y + "px";         

    },

    handleClick: function ( event ) {

        this.showPopWindow( event.clientX, event.clientY );

        // click 的其他代码
        ......
    },

    handleMouseHover: function ( event ) {

        this.showPopWindow( event.clientX, event.clientY );

        // mousehover 的其他代码
        ......

    }

    // 其他事件处理函数
    ......      
};

addListener(element, "click", function (event) {
    app.handleClick(event);
});

addListener(element, "mousehover", function (event) {
    app.handleMouseHover(event);
});

// 其他事件的监听
......

// 当我们想测试的时候，就不在需要重新创建一个event对象了，只需要向下面一样即可
app.showPopWindow( "20", "20" );
</code></pre>

<p>当处理事件时，最好让事件处理程序成为唯一一个接触到 event 对象的函数（即 handleClick 和 handleMouseHover 等）。
事件处理程序应当在进入应用逻辑 showPopWindow 之前对 event 对象执行必要的操作包括阻止默认行为和事件冒泡。最终形成如下代码：</p>

<pre><code>var app =  {

    showPopWindow: function ( x, y ) {

        var popWindow = document.getElementById("popWindow");

        popWindow.style.left = x + "px";
        popWindow.style.top = y + "px";         

    },

    handleClick: function ( event ) {
        // 阻止默认行为
        event.preventDefault();

        // click 的其他代码
        ...... 

        this.showPopWindow( event.clientX, event.clientY );                     
    },

    handleMouseHover: function ( event ) {
        // 阻止默认行为
        event.preventDefault();

        // mousehover 的其他代码
        ......

        this.showPopWindow( event.clientX, event.clientY );

    }

    // 其他事件处理函数
    ......      
};

addListener(element, "click", function (event) {
    app.handleClick(event);
});

addListener(element, "mousehover", function (event) {
    app.handleMouseHover(event);
});

// 其他事件的监听
......
</code></pre>
]]></content>
  </entry>
  
</feed>
