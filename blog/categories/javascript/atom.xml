<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Harole's blog]]></title>
  <link href="http://harole.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://harole.github.com/"/>
  <updated>2013-09-29T23:10:36+08:00</updated>
  <id>http://harole.github.com/</id>
  <author>
    <name><![CDATA[harole]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[函数方法call()和apply()的使用和区别]]></title>
    <link href="http://harole.github.com/blog/2013/09/29/func-method-call-and-apply/"/>
    <updated>2013-09-29T22:40:00+08:00</updated>
    <id>http://harole.github.com/blog/2013/09/29/func-method-call-and-apply</id>
    <content type="html"><![CDATA[<p><strong>call()</strong> 方法和 <strong>apply()</strong> 方法的第一个参数都是要调用的函数对象，在函数体内这一参数是关键字 <strong>this</strong> 的值。call()剩余的参数是传递给要调用的函数的值。</p>

<pre><code>var o = {};

function f( a, b ) {
    console.log(a);
    console.log(b);
}   

// call()方法的使用
f.call( o, 1, 2 );

// call()方法的实现与下面代码实现相似，可以通过下面的代码来理解call()的使用。    
o.m = f;
o.m();
delete o.m;

// apply()方法和call()方法相似，区别在于apply传递给函数的参数是由数组指定的：
f.apply( o, [1,2] );
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[像 html 模块化一样，模块化 javascript 事件处理程序，使之可维护！]]></title>
    <link href="http://harole.github.com/blog/2013/04/10/javascript-event-handle/"/>
    <updated>2013-04-10T12:49:00+08:00</updated>
    <id>http://harole.github.com/blog/2013/04/10/javascript-event-handle</id>
    <content type="html"><![CDATA[<p>一. 常用的事件处理程序</p>

<pre><code>funciton handleClick( event ) {

    var popWindow = document.getElementById("popWindow");

    popWindow.style.left = event.clientX + "px";
    popWindow.style.top = event.clientY + "px"; 

    popWindow.className = "visible";

}
addListener(element, "click", handleClcik); 
</code></pre>

<p>上述程序功能：监听 "element" 元素的 click 事件，当触发 click 事件时，显示一个窗口到当前鼠标位置。</p>

<p>缺点：事件处理程序包含了应用逻辑，即应用逻辑只和 click 事件相关。但是 mousehover，mouseup 等其他事件也要实现同样的功能。会有如下实现：</p>

<!-- more -->


<pre><code>// mousehover
funciton handleMouseHover( event ) {

    var popWindow = document.getElementById("popWindow");

    popWindow.style.left = event.clientX + "px";
    popWindow.style.top = event.clientY + "px"; 

    popWindow.className = "visible";

}
addListener(element, "mousehover", handleMouseHover);       

// mouseup
funciton handleMouseUp( event ) {

    var popWindow = document.getElementById("popWindow");

    popWindow.style.left = event.clientX + "px";
    popWindow.style.top = event.clientY + "px"; 

    popWindow.className = "visible";

}
addListener(element, "mousehover", handleMouseUp);      

// 其他事件
......
</code></pre>

<p>很明显上面的代码被复制了多，于是我们又有了如下代码：</p>

<pre><code>// eventHandle
funciton eventHandle( event ) {

    var popWindow = document.getElementById("popWindow");

    popWindow.style.left = event.clientX + "px";
    popWindow.style.top = event.clientY + "px"; 

    popWindow.className = "visible";

}
addListener(element, "click", eventHandle); 
addListener(element, "mousehover", eventHandle);        
addListener(element, "mousehover", eventHandle);    

// 其他监听事件
......
</code></pre>

<p>恩恩，经过两次改进，我们将应用逻辑从事件处理程序中隔离了。但是，问题并没有解决，因为你监听的事件
"click", "mousehover", "mouseup"等的处理程序大部分情况下是不一样的。于是有了如下方案：</p>

<p>二. 隔离应用逻辑</p>

<pre><code>var app =  {

    showPopWindow: function (event) {

        var popWindow = document.getElementById("popWindow");

        popWindow.style.left = event.clientX + "px";
        popWindow.style.top = event.clientY + "px";         

    },

    handleClick: function (event) {

        this.showPopWindow( event );

        // click 的其他代码
        ......
    },

    handleMouseHover: function (event) {

        this.showPopWindow( event );

        // mousehover 的其他代码
        ......

    }

    // 其他事件处理函数
    ......      
};

addListener(element, "click", function (event) {
    app.handleClick(event);
});

addListener(element, "mousehover", function (event) {
    app.handleMouseHover(event);
});

// 其他事件的监听
......
</code></pre>

<p>隔离应用逻辑后，代码还存在一个问题，即 event 对象被无节制的分发（event 由 addListener 传入了 app.handleClick 或 app.handleMouseHover，再传入app.showPopWindow）。</p>

<p>三. 不要分发事件对象</p>

<p>应用逻辑 showPopWindow 不应该依赖于 event 对象来完成功能。如果想要测试这个方法，必须重新创建一个 event 对象，否则在函数内无法找到 event.clientX 和 event.clientY，就无法测试。所以做了如下改进：</p>

<pre><code>var app =  {

    showPopWindow: function ( x, y ) {

        var popWindow = document.getElementById("popWindow");

        popWindow.style.left = x + "px";
        popWindow.style.top = y + "px";         

    },

    handleClick: function ( event ) {

        this.showPopWindow( event.clientX, event.clientY );

        // click 的其他代码
        ......
    },

    handleMouseHover: function ( event ) {

        this.showPopWindow( event.clientX, event.clientY );

        // mousehover 的其他代码
        ......

    }

    // 其他事件处理函数
    ......      
};

addListener(element, "click", function (event) {
    app.handleClick(event);
});

addListener(element, "mousehover", function (event) {
    app.handleMouseHover(event);
});

// 其他事件的监听
......

// 当我们想测试的时候，就不在需要重新创建一个event对象了，只需要向下面一样即可
app.showPopWindow( "20", "20" );
</code></pre>

<p>当处理事件时，最好让事件处理程序成为唯一一个接触到 event 对象的函数（即 handleClick 和 handleMouseHover 等）。
事件处理程序应当在进入应用逻辑 showPopWindow 之前对 event 对象执行必要的操作包括阻止默认行为和事件冒泡。最终形成如下代码：</p>

<pre><code>var app =  {

    showPopWindow: function ( x, y ) {

        var popWindow = document.getElementById("popWindow");

        popWindow.style.left = x + "px";
        popWindow.style.top = y + "px";         

    },

    handleClick: function ( event ) {
        // 阻止默认行为
        event.preventDefault();

        // click 的其他代码
        ...... 

        this.showPopWindow( event.clientX, event.clientY );                     
    },

    handleMouseHover: function ( event ) {
        // 阻止默认行为
        event.preventDefault();

        // mousehover 的其他代码
        ......

        this.showPopWindow( event.clientX, event.clientY );

    }

    // 其他事件处理函数
    ......      
};

addListener(element, "click", function (event) {
    app.handleClick(event);
});

addListener(element, "mousehover", function (event) {
    app.handleMouseHover(event);
});

// 其他事件的监听
......
</code></pre>
]]></content>
  </entry>
  
</feed>
